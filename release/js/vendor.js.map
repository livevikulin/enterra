{"version":3,"sources":["webpack:///./node_modules/tablesort/src/tablesort.js"],"names":[],"mappings":";;;;;;;;;AAAA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,wBAAwB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,+BAA+B;AAChD;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;;AAEA,mBAAmB,uCAAuC;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,KAA6B;AACnC;AACA,GAAG;AACH;AACA;AACA,CAAC","file":"vendor.js","sourcesContent":[";(function() {\n  function Tablesort(el, options) {\n    if (!(this instanceof Tablesort)) return new Tablesort(el, options);\n\n    if (!el || el.tagName !== 'TABLE') {\n      throw new Error('Element must be a table');\n    }\n    this.init(el, options || {});\n  }\n\n  var sortOptions = [];\n\n  var createEvent = function(name) {\n    var evt;\n\n    if (!window.CustomEvent || typeof window.CustomEvent !== 'function') {\n      evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(name, false, false, undefined);\n    } else {\n      evt = new CustomEvent(name);\n    }\n\n    return evt;\n  };\n\n  var getInnerText = function(el) {\n    return el.getAttribute('data-sort') || el.textContent || el.innerText || '';\n  };\n\n  // Default sort method if no better sort method is found\n  var caseInsensitiveSort = function(a, b) {\n    a = a.trim().toLowerCase();\n    b = b.trim().toLowerCase();\n\n    if (a === b) return 0;\n    if (a < b) return 1;\n\n    return -1;\n  };\n\n  var getCellByKey = function(cells, key) {\n    return [].slice.call(cells).find(function(cell) {\n      return cell.getAttribute('data-sort-column-key') === key;\n    });\n  };\n\n  // Stable sort function\n  // If two elements are equal under the original sort function,\n  // then there relative order is reversed\n  var stabilize = function(sort, antiStabilize) {\n    return function(a, b) {\n      var unstableResult = sort(a.td, b.td);\n\n      if (unstableResult === 0) {\n        if (antiStabilize) return b.index - a.index;\n        return a.index - b.index;\n      }\n\n      return unstableResult;\n    };\n  };\n\n  Tablesort.extend = function(name, pattern, sort) {\n    if (typeof pattern !== 'function' || typeof sort !== 'function') {\n      throw new Error('Pattern and sort must be a function');\n    }\n\n    sortOptions.push({\n      name: name,\n      pattern: pattern,\n      sort: sort\n    });\n  };\n\n  Tablesort.prototype = {\n\n    init: function(el, options) {\n      var that = this,\n          firstRow,\n          defaultSort,\n          i,\n          cell;\n\n      that.table = el;\n      that.thead = false;\n      that.options = options;\n\n      if (el.rows && el.rows.length > 0) {\n        if (el.tHead && el.tHead.rows.length > 0) {\n          for (i = 0; i < el.tHead.rows.length; i++) {\n            if (el.tHead.rows[i].getAttribute('data-sort-method') === 'thead') {\n              firstRow = el.tHead.rows[i];\n              break;\n            }\n          }\n          if (!firstRow) {\n            firstRow = el.tHead.rows[el.tHead.rows.length - 1];\n          }\n          that.thead = true;\n        } else {\n          firstRow = el.rows[0];\n        }\n      }\n\n      if (!firstRow) return;\n\n      var onClick = function() {\n        if (that.current && that.current !== this) {\n          that.current.removeAttribute('aria-sort');\n        }\n\n        that.current = this;\n        that.sortTable(this);\n      };\n\n      // Assume first row is the header and attach a click handler to each.\n      for (i = 0; i < firstRow.cells.length; i++) {\n        cell = firstRow.cells[i];\n        cell.setAttribute('role','columnheader');\n        if (cell.getAttribute('data-sort-method') !== 'none') {\n          cell.tabindex = 0;\n          cell.addEventListener('click', onClick, false);\n\n          if (cell.getAttribute('data-sort-default') !== null) {\n            defaultSort = cell;\n          }\n        }\n      }\n\n      if (defaultSort) {\n        that.current = defaultSort;\n        that.sortTable(defaultSort);\n      }\n    },\n\n    sortTable: function(header, update) {\n      var that = this,\n          columnKey = header.getAttribute('data-sort-column-key'),\n          column = header.cellIndex,\n          sortFunction = caseInsensitiveSort,\n          item = '',\n          items = [],\n          i = that.thead ? 0 : 1,\n          sortMethod = header.getAttribute('data-sort-method'),\n          sortOrder = header.getAttribute('aria-sort');\n\n      that.table.dispatchEvent(createEvent('beforeSort'));\n\n      // If updating an existing sort, direction should remain unchanged.\n      if (!update) {\n        if (sortOrder === 'ascending') {\n          sortOrder = 'descending';\n        } else if (sortOrder === 'descending') {\n          sortOrder = 'ascending';\n        } else {\n          sortOrder = that.options.descending ? 'descending' : 'ascending';\n        }\n\n        header.setAttribute('aria-sort', sortOrder);\n      }\n\n      if (that.table.rows.length < 2) return;\n\n      // If we force a sort method, it is not necessary to check rows\n      if (!sortMethod) {\n        var cell;\n        while (items.length < 3 && i < that.table.tBodies[0].rows.length) {\n          if(columnKey) {\n            cell = getCellByKey(that.table.tBodies[0].rows[i].cells, columnKey);\n          } else {\n            cell = that.table.tBodies[0].rows[i].cells[column];\n          }\n\n          // Treat missing cells as empty cells\n          item = cell ? getInnerText(cell) : \"\";\n\n          item = item.trim();\n\n          if (item.length > 0) {\n            items.push(item);\n          }\n\n          i++;\n        }\n\n        if (!items) return;\n      }\n\n      for (i = 0; i < sortOptions.length; i++) {\n        item = sortOptions[i];\n\n        if (sortMethod) {\n          if (item.name === sortMethod) {\n            sortFunction = item.sort;\n            break;\n          }\n        } else if (items.every(item.pattern)) {\n          sortFunction = item.sort;\n          break;\n        }\n      }\n\n      that.col = column;\n\n      for (i = 0; i < that.table.tBodies.length; i++) {\n        var newRows = [],\n            noSorts = {},\n            j,\n            totalRows = 0,\n            noSortsSoFar = 0;\n\n        if (that.table.tBodies[i].rows.length < 2) continue;\n\n        for (j = 0; j < that.table.tBodies[i].rows.length; j++) {\n          var cell;\n\n          item = that.table.tBodies[i].rows[j];\n          if (item.getAttribute('data-sort-method') === 'none') {\n            // keep no-sorts in separate list to be able to insert\n            // them back at their original position later\n            noSorts[totalRows] = item;\n          } else {\n            if (columnKey) {\n              cell = getCellByKey(item.cells, columnKey);\n            } else {\n              cell = item.cells[that.col];\n            }\n            // Save the index for stable sorting\n            newRows.push({\n              tr: item,\n              td: cell ? getInnerText(cell) : '',\n              index: totalRows\n            });\n          }\n          totalRows++;\n        }\n        // Before we append should we reverse the new array or not?\n        // If we reverse, the sort needs to be `anti-stable` so that\n        // the double negatives cancel out\n        if (sortOrder === 'descending') {\n          newRows.sort(stabilize(sortFunction, true));\n        } else {\n          newRows.sort(stabilize(sortFunction, false));\n          newRows.reverse();\n        }\n\n        // append rows that already exist rather than creating new ones\n        for (j = 0; j < totalRows; j++) {\n          if (noSorts[j]) {\n            // We have a no-sort row for this position, insert it here.\n            item = noSorts[j];\n            noSortsSoFar++;\n          } else {\n            item = newRows[j - noSortsSoFar].tr;\n          }\n\n          // appendChild(x) moves x if already present somewhere else in the DOM\n          that.table.tBodies[i].appendChild(item);\n        }\n      }\n\n      that.table.dispatchEvent(createEvent('afterSort'));\n    },\n\n    refresh: function() {\n      if (this.current !== undefined) {\n        this.sortTable(this.current, true);\n      }\n    }\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Tablesort;\n  } else {\n    window.Tablesort = Tablesort;\n  }\n})();\n"],"sourceRoot":""}